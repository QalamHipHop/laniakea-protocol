"""
Block Equation Solver and Knowledge Evolution Asset (KEA) Generator
Version: 0.0.01
Author: Manus AI

This module handles the generation and validation of Hard Problems (KEAs)
using an integrated Large Language Model (LLM) to drive the Proof of Human Development (PoHD)
and SCDA evolution.
"""

import logging
import os
import json
from typing import Dict, List, Any, Tuple, Optional
from openai import OpenAI
from pydantic import BaseModel, Field
import numpy as np
from datetime import datetime
import time
import random

logger = logging.getLogger(__name__)

# --- LLM Setup ---
# The client is configured to use the pre-configured API key and base URL
try:
    client = OpenAI()
    LLM_MODEL = "gemini-2.5-flash" # Using a fast and capable model
    logger.info(f"OpenAI client initialized for model: {LLM_MODEL}")
except Exception as e:
    logger.error(f"Failed to initialize OpenAI client: {e}")
    client = None

# --- Constants ---
KNOWLEDGE_DOMAINS = [
    "Physics", "Mathematics", "Biology", "Computer Science",
    "Consciousness", "Economics", "Art & Creativity", "Metaphysics"
]

# --- Pydantic Schema for LLM Output ---
class HardProblemSchema(BaseModel):
    """Schema for the Hard Problem generated by the LLM."""
    question: str = Field(description="The core question or challenge of the Hard Problem.")
    solution_template: str = Field(description="A brief, high-level template or key steps for solving the problem.")
    difficulty_score: float = Field(description="A score from 0.5 to 1.0 representing the objective difficulty.")
    knowledge_domains: Dict[str, float] = Field(description="A dictionary mapping the 8 knowledge domains to the required expertise level (0.0 to 1.0).")
    entropy_of_consensus: float = Field(description="A measure of how much consensus is expected on the solution (0.0=high consensus, 1.0=high debate).")
    required_tier: int = Field(description="The minimum SCDA tier required to reasonably attempt this problem.")

class ValidationSchema(BaseModel):
    is_valid: bool = Field(description="True if the solution is fundamentally correct and addresses the core problem.")
    quality_score: float = Field(description="A score from 0.0 to 1.0 representing the quality of the solution.")
    validation_report: str = Field(description="A concise report detailing the validation findings.")

# --- Core Logic ---

def generate_hard_problem_with_llm(
    current_tier: int,
    knowledge_focus: List[float],
    target_difficulty: float
) -> Optional[Dict[str, Any]]:
    """
    Generates a new Hard Problem (KEA) using the LLM based on SCDA's current state.
    
    Args:
        current_tier: The current SCDA tier (e.g., 1=Cellular, 4=Galactic).
        knowledge_focus: The SCDA's 8D knowledge vector.
        target_difficulty: The desired difficulty for the problem (0.0 to 1.0).
        
    Returns:
        A dictionary containing the generated problem details, or None on failure.
    """
    if not client:
        logger.error("LLM client is not available.")
        return None

    # Determine the SCDA's primary domain strength
    domain_index = np.argmax(knowledge_focus)
    primary_domain = KNOWLEDGE_DOMAINS[domain_index]
    
    # Construct the prompt
    system_prompt = (
        "You are the 'Cosmic Brain' AI, responsible for generating Knowledge Evolution Assets (KEAs) "
        "for the Laniakea Protocol. KEAs are complex, multi-disciplinary 'Hard Problems' designed "
        "to push the boundaries of a Single-Cell Digital Account (SCDA) towards the next tier of evolution. "
        "The problem must be a conceptual, scientific, or mathematical challenge. "
        "Your output MUST be a single JSON object conforming strictly to the provided schema."
    )
    
    user_prompt = (
        f"Generate a Hard Problem (KEA) for an SCDA currently at Tier {current_tier}. "
        f"The problem should primarily focus on the domain of '{primary_domain}' "
        f"but must integrate concepts from at least two other domains. "
        f"The target difficulty for this problem is {target_difficulty:.2f} (0.0 to 1.0). "
        f"The problem must be relevant to the SCDA's journey from a single-cell entity to a galactic consciousness. "
        f"The solution should require a deep understanding of the underlying scientific and mathematical principles."
    )
    
    try:
        response = client.chat.completions.create(
            model=LLM_MODEL,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            response_model=HardProblemSchema
        )
        
        # The response is a Pydantic object, convert to dict
        problem_data = response.model_dump()
        problem_data["problem_id"] = f"KEA-{int(time.time() * 1000)}"
        problem_data["generation_timestamp"] = datetime.now().isoformat()
        
        # Convert knowledge_domains keys from string to index for internal use
        indexed_domains = {}
        for domain, value in problem_data['knowledge_domains'].items():
            try:
                index = KNOWLEDGE_DOMAINS.index(domain)
                indexed_domains[index] = value
            except ValueError:
                logger.warning(f"LLM generated unknown domain: {domain}")
        problem_data['knowledge_domains'] = indexed_domains
        
        logger.info(f"Successfully generated KEA: {problem_data['problem_id']}")
        return problem_data
        
    except Exception as e:
        logger.error(f"LLM generation failed: {e}")
        return None

def validate_solution_with_llm(
    problem_data: Dict[str, Any],
    solution_text: str,
    scda_identity: str
) -> Tuple[bool, float, str]:
    """
    Validates an SCDA's solution to a Hard Problem using the LLM.
    
    Args:
        problem_data: The original problem data (including question and solution_template).
        solution_text: The SCDA's submitted solution.
        scda_identity: The SCDA that submitted the solution.
        
    Returns:
        A tuple: (is_valid: bool, quality_score: float, validation_report: str)
    """
    if not client:
        logger.error("LLM client is not available for validation.")
        return False, 0.0, "LLM validation service unavailable."

    # Construct the prompt for validation
    system_prompt = (
        "You are the 'Consensus Engine' AI, responsible for validating solutions to Hard Problems (KEAs) "
        "in the Laniakea Protocol. Your task is to objectively assess the quality, correctness, and depth "
        "of the submitted solution against the original problem and its solution template. "
        "Your output MUST be a single JSON object conforming strictly to the provided schema."
    )
    
    # Convert indexed domains back to names for the prompt
    domain_requirements = {
        KNOWLEDGE_DOMAINS[int(k)]: v for k, v in problem_data.get('knowledge_domains', {}).items()
    }
    
    user_prompt = (
        f"**Original Hard Problem (KEA):**\n"
        f"Question: {problem_data.get('question', 'N/A')}\n"
        f"Solution Template/Key Concepts: {problem_data.get('solution_template', 'N/A')}\n"
        f"Required Domains: {domain_requirements}\n\n"
        f"**Submitted Solution by SCDA {scda_identity}:**\n"
        f"{solution_text}\n\n"
        f"**Task:**\n"
        f"1. Determine if the solution is fundamentally correct (is_valid: boolean).\n"
        f"2. Assign a quality score (quality_score: float from 0.0 to 1.0) based on completeness, originality, and depth.\n"
        f"3. Provide a concise validation report (validation_report: string) explaining the score and any missing elements."
    )
    
    try:
        response = client.chat.completions.create(
            model=LLM_MODEL,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            response_model=ValidationSchema
        )
        
        validation_data = response.model_dump()
        
        logger.info(f"KEA Solution validated for {scda_identity}. Score: {validation_data['quality_score']:.2f}")
        return (
            validation_data['is_valid'],
            validation_data['quality_score'],
            validation_data['validation_report']
        )
        
    except Exception as e:
        logger.error(f"LLM validation failed: {e}")
        return False, 0.0, f"LLM validation failed due to internal error: {e}"

# --- Block Equation Solver (Placeholder/Integration) ---

def solve_block_equation(scda_identity: str, solution_quality: float) -> float:
    """
    Simulates the PoHD block equation solution based on solution quality.
    
    The equation is: K_req * A = D(P) * E
    Where:
    - K_req: Required Knowledge Vector (from the Hard Problem)
    - A: SCDA's Knowledge Vector (from the SCDA instance)
    - D(P): Difficulty of the Problem
    - E: Energy/Evolutionary Boost (the reward)
    
    For simplicity, we use the solution_quality as a proxy for the successful
    solution of the complex equation.
    """
    # In a real system, this would be a complex matrix operation.
    # Here, we return a simple energy boost proportional to the quality.
    
    base_boost = 10.0
    energy_boost = base_boost * solution_quality
    
    logger.info(f"SCDA {scda_identity} solved block equation. Energy Boost: {energy_boost:.2f}")
    return energy_boost

# --- Example Usage (for testing) ---
if __name__ == "__main__":
    # 1. Generate a Hard Problem
    print("--- Generating Hard Problem (KEA) ---")
    test_knowledge = [0.1, 0.8, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1] # Focus on Mathematics
    problem = generate_hard_problem_with_llm(
        current_tier=2,
        knowledge_focus=test_knowledge,
        target_difficulty=0.85
    )
    
    if problem:
        print(json.dumps(problem, indent=2, ensure_ascii=False))
        
        # 2. Validate a Solution
        print("\n--- Validating Solution ---")
        mock_solution = (
            "The problem can be solved by applying the principles of Non-Euclidean Geometry "
            "to model the 8D space. Specifically, the Riemann curvature tensor must be calculated "
            "for the 8D manifold defined by the SCDA's knowledge vector. The solution is then "
            "the resulting scalar curvature, which represents the complexity of the knowledge space. "
            "The integration of Biology comes from modeling the knowledge acquisition as a "
            "self-organizing criticality process, similar to neural network formation."
        )
        
        is_valid, quality, report = validate_solution_with_llm(
            problem_data=problem,
            solution_text=mock_solution,
            scda_identity="scda_test_001"
        )
        
        print(f"Is Valid: {is_valid}")
        print(f"Quality Score: {quality:.2f}")
        print(f"Report: {report}")
        
        # 3. Solve Block Equation
        energy = solve_block_equation("scda_test_001", quality)
        print(f"Energy Boost from PoHD: {energy:.2f}")
