<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Laniakea Protocol - 8D to 3D Metaverse Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 100%);
            color: #e0e0e0;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .header {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #667eea;
            max-width: 400px;
            pointer-events: auto;
        }
        
        .header h1 {
            color: #667eea;
            font-size: 1.5em;
            margin-bottom: 10px;
            text-align: right;
        }

        .header p {
            font-size: 0.9em;
            line-height: 1.5;
            text-align: right;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid #667eea;
            pointer-events: auto;
            display: flex;
            gap: 15px;
        }

        .controls label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
        }

        .controls input[type="range"] {
            width: 100px;
        }
    </style>
</head>
<body>
    <div id="canvas"></div>
    <div class="ui-overlay">
        <div class="header">
            <h1>ویژوال‌سازی متاورس ۸بعدی</h1>
            <p>
                این ویژوال‌سازی، نقاط داده ۸بعدی را با استفاده از یک تبدیل خطی (ماتریس پروجکشن) به فضای ۳بعدی قابل مشاهده تبدیل می‌کند.
                این نقاط نشان‌دهنده موجودیت‌ها یا حالت‌های پیچیده در پروتکل لانی‌آکیا هستند.
            </p>
        </div>
        <div class="controls">
            <label>
                سرعت چرخش:
                <input type="range" id="rotationSpeed" min="0" max="0.01" step="0.0001" value="0.001">
            </label>
            <label>
                تعداد نقاط:
                <input type="range" id="pointCount" min="100" max="5000" step="100" value="1000">
            </label>
        </div>
    </div>

    <script>
        // --- Three.js Setup ---
        let scene, camera, renderer, particles, controls;
        let pointCount = 1000;
        let rotationSpeed = 0.001;

        // 8D to 3D Projection Matrix (3x8 matrix)
        // This is a simple, fixed projection for demonstration.
        // In a real application, this matrix could be dynamic (e.g., learned via PCA or a neural network).
        const PROJECTION_MATRIX = [
            [1, 0, 0, 0, 0.5, 0, 0, 0], // X' = x1 + 0.5*x5
            [0, 1, 0, 0, 0, 0.5, 0, 0], // Y' = x2 + 0.5*x6
            [0, 0, 1, 0, 0, 0, 0.5, 0]  // Z' = x3 + 0.5*x7
        ];

        // Function to generate a random 8D point
        function generate8DPoint() {
            return new Array(8).fill(0).map(() => (Math.random() - 0.5) * 100); // Range [-50, 50]
        }

        // Function to project an 8D point to a 3D point
        function project8DTo3D(point8D) {
            let point3D = new Array(3).fill(0);
            for (let i = 0; i < 3; i++) { // 3D output dimensions
                for (let j = 0; j < 8; j++) { // 8D input dimensions
                    point3D[i] += PROJECTION_MATRIX[i][j] * point8D[j];
                }
            }
            return point3D;
        }

        // Array to hold the original 8D data
        let data8D = [];

        function init() {
            const container = document.getElementById('canvas');
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e27);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 150;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            // Controls (optional, for user interaction)
            // Note: We are not including a full OrbitControls library here for simplicity,
            // but a basic rotation is implemented in the animate loop.

            // Initial Data Generation
            generateData(pointCount);

            // Event Listeners for UI
            document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                rotationSpeed = parseFloat(e.target.value);
            });

            document.getElementById('pointCount').addEventListener('input', (e) => {
                const newCount = parseInt(e.target.value);
                if (newCount !== pointCount) {
                    pointCount = newCount;
                    generateData(pointCount);
                }
            });

            window.addEventListener('resize', onWindowResize, false);
        }

        function generateData(count) {
            // Clear previous particles
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
                particles.material.dispose();
            }

            data8D = [];
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color();

            for (let i = 0; i < count; i++) {
                const p8D = generate8DPoint();
                data8D.push(p8D);
                const p3D = project8DTo3D(p8D);

                positions.push(p3D[0], p3D[1], p3D[2]);

                // Color based on one of the higher dimensions (e.g., 8th dimension)
                // This adds a visual cue for the projected data's original properties
                const colorValue = (p8D[7] + 50) / 100; // Normalize from [-50, 50] to [0, 1]
                color.setHSL(colorValue, 1.0, 0.5); // Hue based on 8th dimension
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.5,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Simple rotation of the entire particle system
            particles.rotation.x += rotationSpeed;
            particles.rotation.y += rotationSpeed * 0.5;

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
